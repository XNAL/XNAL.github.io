<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      使用node.js开发一个小爬虫 | DON 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Don">
    
    

    <meta name="description" content="前言很多程序猿在最开始学习开发的时候应该都有一个想要自己开发一个爬虫的想法（至少我是有的）。所以国内网络上也是爬虫盛行！学了node.js之后发现比较适合写爬虫，不过一直没有动手去写，正好这段时间比较闲，就写个爬虫玩下。 想着爬个什么东西呢？正好都比较喜欢看电影，那就从时光网爬下国内的票房排行榜吧。 Talk is cheap. Show me the code不bb，代码在此">
<meta name="keywords" content="node.js,网页爬虫">
<meta property="og:type" content="article">
<meta property="og:title" content="使用node.js开发一个小爬虫 | DON">
<meta property="og:url" content="http://yoursite.com/2017/09/20/使用node-js开发一个小爬虫/index.html">
<meta property="og:site_name" content="DON">
<meta property="og:description" content="前言很多程序猿在最开始学习开发的时候应该都有一个想要自己开发一个爬虫的想法（至少我是有的）。所以国内网络上也是爬虫盛行！学了node.js之后发现比较适合写爬虫，不过一直没有动手去写，正好这段时间比较闲，就写个爬虫玩下。 想着爬个什么东西呢？正好都比较喜欢看电影，那就从时光网爬下国内的票房排行榜吧。 Talk is cheap. Show me the code不bb，代码在此">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-10-09T12:53:25.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用node.js开发一个小爬虫 | DON">
<meta name="twitter:description" content="前言很多程序猿在最开始学习开发的时候应该都有一个想要自己开发一个爬虫的想法（至少我是有的）。所以国内网络上也是爬虫盛行！学了node.js之后发现比较适合写爬虫，不过一直没有动手去写，正好这段时间比较闲，就写个爬虫玩下。 想着爬个什么东西呢？正好都比较喜欢看电影，那就从时光网爬下国内的票房排行榜吧。 Talk is cheap. Show me the code不bb，代码在此">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">DON</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          全栈开发、卖码为生
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/project" title="" class="">项目</a></li>
              
                
                <li class="navigation__item"><a href="/categories" title="" class="">分类</a></li>
              
                
                <li class="navigation__item"><a href="/tags" title="" class="">标签</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">使用node.js开发一个小爬虫</h1>

    

    <div class="post-meta">
      <time datetime="2017-09-20" class="post-meta__date date">2017-09-20</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/项目实战/">项目实战</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/node-js/">node.js</a>, <a class="tags-link" href="/tags/网页爬虫/">网页爬虫</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很多程序猿在最开始学习开发的时候应该都有一个想要自己开发一个爬虫的想法（至少我是有的）。所以国内网络上也是爬虫盛行！学了node.js之后发现比较适合写爬虫，不过一直没有动手去写，正好这段时间比较闲，就写个爬虫玩下。</p>
<p>想着爬个什么东西呢？正好都比较喜欢看电影，那就从时光网爬下国内的票房排行榜吧。</p>
<h3 id="Talk-is-cheap-Show-me-the-code"><a href="#Talk-is-cheap-Show-me-the-code" class="headerlink" title="Talk is cheap. Show me the code"></a>Talk is cheap. Show me the code</h3><p><a href="https://github.com/XNAL/node-MovieSpider" target="_blank" rel="external">不bb，代码在此</a></p>
<a id="more"></a> 
<h3 id="如何”食用”"><a href="#如何”食用”" class="headerlink" title="如何”食用”"></a>如何”食用”</h3><pre><code>git clone https://github.com/XNAL/node-MovieSpider

cd node-MovieSpider 

npm init

node index.js
</code></pre><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ul>
<li>开发语言：<a href="https://nodejs.org/en/" target="_blank" rel="external">node.js</a></li>
<li>发出http请求：<a href="http://visionmedia.github.io/superagent/" target="_blank" rel="external">superagent</a></li>
<li>并发控制：<a href="https://caolan.github.io/async/" target="_blank" rel="external">async</a></li>
<li>分析网页内容：<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio</a></li>
</ul>
<h3 id="开始撸代码"><a href="#开始撸代码" class="headerlink" title="开始撸代码"></a>开始撸代码</h3><h4 id="1-代码主体"><a href="#1-代码主体" class="headerlink" title="1. 代码主体"></a>1. 代码主体</h4><p>作为一个简单的示例，此次就不开启node服务了，我这里就直接来个自执行的方法。如果有需要，可以根据自己的需求扩展。</p>
<pre><code>// 启动时直接执行代码 
(function spider() {
    util.fetch_data_get(reqUrl, reqParams)
        .then((result) =&gt; {
            // 根据页面结构获取总的页数，然后再分页获取数据
            let $ = cheerio.load(result.body.html);
            let pageTotal = $(&apos;.bocontent .pagesize a:last-child&apos;).data(&apos;page&apos;) || 0;
            console.log(&apos;电影数据总页数：&apos;, pageTotal);
            return pageTotal;
        })
        .then((pageTotal) =&gt; {
            // 分页获取数据
            getMovieData(0, pageTotal);
        })
        .catch((err) =&gt; {
            console.log(&apos;获取链接失败：&apos;, err);
        })
})();
</code></pre><h4 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2. 发送请求"></a>2. 发送请求</h4><p>因为代码中需要多次发送http请求，所以把http请求写成一个公共方法会比较好。使用上面提到<code>superagent</code>库来实现。</p>
<pre><code>// 公共方法：通过get请求获取数据
function fetch_data_get(url, queryParams) {
    return new Promise((reslove, reject) =&gt; {
        superagent
            .get(url)
            .set(setting.header)
            .query(queryParams)
            .end((err, result) =&gt; {
                err ? reject(err) : reslove(result);
            })
    })
}
</code></pre><h4 id="3-分析目标网站api"><a href="#3-分析目标网站api" class="headerlink" title="3. 分析目标网站api"></a>3. 分析目标网站api</h4><p>根据人工操作得来的api<code>http://movie.mtime.com/boxoffice/?year=2017&amp;area=china&amp;type=MovieRankingYear&amp;category=all&amp;page=0&amp;display=list&amp;timestamp=1505818638620&amp;version=07bb781100018dd58eafc3b35d42686804c6df8d&amp;dataType=json</code>可以得到以下参数：</p>
<pre><code>// 根据网站api得到相应的url和参数
const reqUrl = &apos;http://movie.mtime.com/boxoffice/&apos;;
const reqParams = {
    &apos;year&apos;: 2017,
    &apos;area&apos;: &apos;china&apos;,
    &apos;type&apos;: &apos;MovieRankingYear&apos;,
    &apos;category&apos;: &apos;all&apos;,
    &apos;page&apos;: 0,
    &apos;display&apos;: &apos;list&apos;,
    &apos;timestamp&apos;: 1501576013654,
    &apos;version&apos;: &apos;07bb781100018dd58eafc3b35d42686804c6df8d&apos;,
    &apos;dataType&apos;: &apos;json&apos;
};
</code></pre><p>因为此次要获取的是<code>2017年内地票房排行榜</code>。根据分析可知：需要变动的主要是<code>page</code>参数，那这里就需要根据页面返回的内容来取得总的<code>page</code>。</p>
<h4 id="4-使用cheerio获取所需参数"><a href="#4-使用cheerio获取所需参数" class="headerlink" title="4. 使用cheerio获取所需参数"></a>4. 使用cheerio获取所需参数</h4><p>api返回的页面内容可查看：<a href="https://github.com/XNAL/node-MovieSpider/blob/master/time.html" target="_blank" rel="external">将api获取的数据格式化后的页面代码</a>。</p>
<p>这里需要用到<code>cheerio</code>来取页码总数的代码，<code>cheerio</code>可以理解为服务器端的jQuery，用法也类似：</p>
<pre><code>// 根据页面结构获取总的页数，然后再分页获取数据
let $ = cheerio.load(result.body.html);
let pageTotal = $(&apos;.bocontent .pagesize a:last-child&apos;).data(&apos;page&apos;) || 0;
</code></pre><h4 id="5-开始分页取目标数据"><a href="#5-开始分页取目标数据" class="headerlink" title="5. 开始分页取目标数据"></a>5. 开始分页取目标数据</h4><p><1> 调用上面所说的公共方法<code>fetch_data_get</code>获取数据，然后取页面内容，图片地址都先保存在<code>movieImgs</code>中，最后再统一下载图片：</1></p>
<pre><code>// 根据页面结构获取所需数据
let $ = cheerio.load(result.body.html);
$(&apos;.bocontent .boxofficelist dd&apos;).each((idx, elem) =&gt; {
    $(elem).find(&apos;div.movietopmod&apos;).each((i, el) =&gt; {
        let _this = $(el);
        let arrLeadActor = [];
        _this.find(&apos;.txtbox b p&apos;).eq(1).find(&apos;a&apos;).each((idx, ela) =&gt; {
            arrLeadActor.push($(ela).text());
        })
        movieData.push({
            rank: _this.find(&apos;.picbox i&apos;).text(),
            img: _this.find(&apos;.picbox img&apos;).attr(&apos;src&apos;).replace(/\/u\//, &quot;&quot;),
            name: _this.find(&apos;.txtbox h3&apos;).text(),
            director: _this.find(&apos;.txtbox b p&apos;).eq(0).find(&apos;a&apos;).text(),
            leadActor: arrLeadActor.join(&apos;,&apos;),
            point: _this.find(&apos;.gradebox .point&apos;).text(),
            total: _this.find(&apos;.totalbox .totalnum&apos;).text()
        }),
        movieImgs.push(_this.find(&apos;.picbox img&apos;).attr(&apos;src&apos;).replace(/\/u\//, &quot;&quot;));
    })
})
</code></pre><p><2> 根据页码循环取数据</2></p>
<pre><code>if(pageIndex &lt;= pageTotal) {
    // 设置timeout防止网站反爬虫
    setTimeout(() =&gt; {
        pageIndex ++;
        getMovieData(pageIndex, pageTotal);
    }, setting.timeout);
} 
</code></pre><p><3> 全部数据取出后存储数据，并下载图片。</3></p>
<p>因为只是一个简单的示例，所以此次数据只是保存到<code>json</code>文件中。如果需要对数据进行后续操作的话，那就最好保存到数据库中：</p>
<pre><code>fs.writeFile(dataDir + reqParams.year + &apos;.json&apos;, JSON.stringify(movieData), (err) =&gt; {
    if (err) {
        console.log(err);
    } else {
        console.log(&apos;数据写入成功&apos;);
    }
});
</code></pre><p>调用下载图片的方法：</p>
<pre><code>let folderName = imgPrefix + reqParams.year;
util.downloadImg(movieImgs, folderName);
</code></pre><p><code>util.js</code>中的<code>downloadImg</code>方法：这里就需要用到上面所说的<code>async</code>，使用<code>async</code>是为了进行并发控制，不然极短时间发送至少几十几百次的请求，这种情况弄不好就被网站的发爬虫程序给封了，而且大量并发也会导致出错的概率更高。</p>
<pre><code>// 异步下载图片
function downloadImg(urls, folderName) {
    async.mapLimit(urls, setting.asyncNum, (img, callback) =&gt; {
        fetch_data_get(img, {})
            .then((result) =&gt; {
                let fileName = path.basename(img);
                let folder = imgDir + folderName;
                if(!fs.existsSync(folder)) {
                    fs.mkdirSync(folder);
                }
                fs.writeFile(folder + &apos;/&apos; + fileName, result.body, (err) =&gt; {
                    if (err) {
                        console.log(img, &apos;图片写入失败：&apos;, err);
                    } else {
                        console.log(img, &apos;图片写入成功&apos;);
                        callback(null , fileName);
                    }
                })
            })
            .catch((err) =&gt; console.log(err))
    }, (err, result) =&gt; {
        if (err) {
            console.log(&apos;图片下载失败：&apos;, err)
        } else {
            console.log(result);
        }
    })
}
</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>到此为止一个简单的node.js版的小爬虫就开发完成了。其实弄懂了爬虫的原理，再回过头去看，发现开发一个简单的爬虫来说还是很容易的。</p>
<p>最后，欢迎大家去<a href="https://github.com/XNAL" target="_blank" rel="external">我的github</a>进行<code>star</code>和<code>fork</code>。</p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
